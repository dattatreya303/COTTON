<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COTTON: cotton Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COTTON
   </div>
   <div id="projectbrief">COTTON: A light-weight work-stealing runtime for async-finish parallelism.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cotton Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcotton_1_1Deque.html">Deque</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4ea9036584fa3bd86fe8626dc05d295f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#a4ea9036584fa3bd86fe8626dc05d295f">lib_key_init</a> ()</td></tr>
<tr class="separator:a4ea9036584fa3bd86fe8626dc05d295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebe1f6821a54e7c4911c22acebff8a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#ab1ebe1f6821a54e7c4911c22acebff8a">get_threadID</a> ()</td></tr>
<tr class="separator:ab1ebe1f6821a54e7c4911c22acebff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22caee9434a7e06a09b2f9a0417c1eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#af22caee9434a7e06a09b2f9a0417c1eb">find_and_execute_task</a> ()</td></tr>
<tr class="separator:af22caee9434a7e06a09b2f9a0417c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b32dd3b6a3d126e107d5c77ec1f4cc3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#a0b32dd3b6a3d126e107d5c77ec1f4cc3">thread_pool_size</a> ()</td></tr>
<tr class="separator:a0b32dd3b6a3d126e107d5c77ec1f4cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361c34063ecb68cf02d417074decb12b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#a361c34063ecb68cf02d417074decb12b">worker_routine</a> (void *args)</td></tr>
<tr class="separator:a361c34063ecb68cf02d417074decb12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaca8aa46092d066bf1d996ae09fb83d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#afaca8aa46092d066bf1d996ae09fb83d">grab_task_from_runtime</a> ()</td></tr>
<tr class="separator:afaca8aa46092d066bf1d996ae09fb83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2001813bd051cd1ff41a75989667c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#a2b2001813bd051cd1ff41a75989667c0">push_task_to_runtime</a> (std::function&lt; void()&gt; &amp;&amp;lambda)</td></tr>
<tr class="separator:a2b2001813bd051cd1ff41a75989667c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae391d31cf35efbf9e644206001d7fc6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#ae391d31cf35efbf9e644206001d7fc6d">init_runtime</a> ()</td></tr>
<tr class="separator:ae391d31cf35efbf9e644206001d7fc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7e86503c4fd0c48774e2ffc43d947a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#a3a7e86503c4fd0c48774e2ffc43d947a">async</a> (std::function&lt; void()&gt; &amp;&amp;lambda)</td></tr>
<tr class="separator:a3a7e86503c4fd0c48774e2ffc43d947a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae085573bf6951565449c429ac59c43c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#aae085573bf6951565449c429ac59c43c">start_finish</a> ()</td></tr>
<tr class="separator:aae085573bf6951565449c429ac59c43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab413e05e91ff6e4918aa9aa63d52b2ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#ab413e05e91ff6e4918aa9aa63d52b2ff">end_finish</a> ()</td></tr>
<tr class="separator:ab413e05e91ff6e4918aa9aa63d52b2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3061b2929300562580e4bf1416372c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecotton.html#a3061b2929300562580e4bf1416372c3f">finalize_runtime</a> ()</td></tr>
<tr class="separator:a3061b2929300562580e4bf1416372c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3a7e86503c4fd0c48774e2ffc43d947a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7e86503c4fd0c48774e2ffc43d947a">&#9670;&nbsp;</a></span>async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::async </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the task and pushes it to the calling thread's deque data structure and increments the finish counter after taking a lock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>Takes the task encapsulated in a lamda function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="ab413e05e91ff6e4918aa9aa63d52b2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab413e05e91ff6e4918aa9aa63d52b2ff">&#9670;&nbsp;</a></span>end_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::end_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keeps spinning until the calling thread cannot find any task so that we can avoid it being idle</p>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="a3061b2929300562580e4bf1416372c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3061b2929300562580e4bf1416372c3f">&#9670;&nbsp;</a></span>finalize_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::finalize_runtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits till all the threads that have been spawed have finished executing the tasks</p>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="af22caee9434a7e06a09b2f9a0417c1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22caee9434a7e06a09b2f9a0417c1eb">&#9670;&nbsp;</a></span>find_and_execute_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::find_and_execute_task </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a task from the per thread deque data structures, executes it and finally decrements the volatile finish counter after acquiring the lock</p>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="ab1ebe1f6821a54e7c4911c22acebff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ebe1f6821a54e7c4911c22acebff8a">&#9670;&nbsp;</a></span>get_threadID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cotton::get_threadID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the calling thread's ID used to access the per thread deque data structure</p>
<dl class="section return"><dt>Returns</dt><dd>Thread ID of the calling thread </dd></dl>

</div>
</div>
<a id="afaca8aa46092d066bf1d996ae09fb83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaca8aa46092d066bf1d996ae09fb83d">&#9670;&nbsp;</a></span>grab_task_from_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void()&gt; cotton::grab_task_from_runtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops or steals a task encapsulated as a lambda function from the caller or the victim thread's deque data structure.</p>
<p>It first checks in the calling thread deque data structure and if if does not find any then it tries to steal for other threads' deque data structure. All this is done after taking the necessary locks to avoid data races</p>
<dl class="section return"><dt>Returns</dt><dd>Task encapsulated in a lambda function </dd></dl>

</div>
</div>
<a id="ae391d31cf35efbf9e644206001d7fc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae391d31cf35efbf9e644206001d7fc6d">&#9670;&nbsp;</a></span>init_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::init_runtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spawns all the required threads after initializing the pthread key and setting the ID of the main thread</p>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="a4ea9036584fa3bd86fe8626dc05d295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea9036584fa3bd86fe8626dc05d295f">&#9670;&nbsp;</a></span>lib_key_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::lib_key_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper to initialize the value of the pthread key variable with proper error checking</p>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="a2b2001813bd051cd1ff41a75989667c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2001813bd051cd1ff41a75989667c0">&#9670;&nbsp;</a></span>push_task_to_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::push_task_to_runtime </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a task encapsulated in a lambda function into the calling thread's data structure</p>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="aae085573bf6951565449c429ac59c43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae085573bf6951565449c429ac59c43c">&#9670;&nbsp;</a></span>start_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cotton::start_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the value of the finish counter</p>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="a0b32dd3b6a3d126e107d5c77ec1f4cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b32dd3b6a3d126e107d5c77ec1f4cc3">&#9670;&nbsp;</a></span>thread_pool_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cotton::thread_pool_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper to get the value mentioned in the environment variable COTTON_WORKERS</p>
<dl class="section return"><dt>Returns</dt><dd>Number of threads to use at max </dd></dl>

</div>
</div>
<a id="a361c34063ecb68cf02d417074decb12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361c34063ecb68cf02d417074decb12b">&#9670;&nbsp;</a></span>worker_routine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * cotton::worker_routine </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encapsulates the work that a thread does once spawing which includes setting the per thread ID and spinning until the thread finds a task to execute</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Contains the argument related to the ID of the calling thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
